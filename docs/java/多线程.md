# 多线程
## 进程与线程的区别
进程(Process)对于操作系统来说就是一个任务的执行过程，线程(Thread)是进程的子任务，一个进程可以有多个线程，但至少要有一个线程。一个应用程序可以理解为一个进程（不一定只有一个), 进程执行时可以开启由多个线程同一时间处理不同的任务。  

## 创建线程的方式 
- 实现Runnable接口，new 一个Thread对象通过构造方法传入实现了Runnable接口的对象，调用start()方法
- new 一个Thread对象的子类，子类中重写run方法，调用start()方法。
- 使用线程池提交任务开启线程  
  
`Thread` 类本身实现了Runnable接口，但是实际调用的是构造方法传入的Runnable接口，类似于设计模式中的`装饰者模式(Decorator pattern)`

> 要通过开启线程执行任务，必须调用start()方法，而不是run()，前者是通过native 方法启用线程执行run(), 后者是当前线程调用一个普通的方法。  

## Synchronized关键字
* 被`synchronized`修饰的代码块或方法为同步的，在多线程情况下JVM能够保证其线程安全。  
* JDK 1.6中引入了偏向锁、轻量锁和重量锁的概念，这些锁是基于对synchronized优化而出现的概念，由jvm内部实现，和`ReentrantLock`这类锁有本质区别。  
	- **偏向锁：** JDK1.6引入的一个重要的概念，JDK的开发人员经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。也就是说在很多时候我们是假设有多线程的场景，但是实际上却是单线程的。所以偏向锁是在单线程执行代码块时使用的机制。
	- **轻量级锁：** 如果获取偏向锁失败，也就是有多个线程竞争锁的话，就会升级为JDK1.6引入的轻量级锁，Mark Word 的结构也变为轻量级锁的结构。执行同步代码块之前，JVM会在线程的栈帧中创建一个锁记录（Lock Record），并将Mark Word拷贝复制到锁记录中。然后尝试通过CAS操作将Mark Word中的锁记录的指针，指向创建的Lock Record。如果成功表示获取锁状态成功，如果失败，则进入自旋获取锁状态。
	- **重量级锁:** 重量级锁就是一个悲观锁了，但是其实不是最坏的锁，因为升级到重量级锁，是因为线程占用锁的时间长(自旋获取失败)，锁竞争激烈的场景，在这种情况下，让线程进入阻塞状态，进入阻塞队列，能减少cpu消耗。所以说在不同的场景使用最佳的解决方案才是最好的技术。synchronized在不同的场景会自动选择不同的锁，这样一个升级锁的策略就体现出了这点。

> 原理: 在JVM中，对象在内存中分为三个区域分别是对象头、实例数据、对齐填充，在对象头中的 **Mark Word** 用于存储锁状态、偏向线程ID、偏向时间戳等信息。


## 线程的6种状态及含义
**NEW**:  线程对象已创建，还未调用start方法，该状态只会在start()调用前出现  
**RUNNABLE**: 线程在Java虚拟机中已是执行状态 (对于操作系统来说可能处于等待阶段，比如等待处理器资源)  
**BLOCKED**: 线程阻塞，等待其它线程释放锁，如被synchronized修饰的对象同一时间只能由一个线程获取，其它访问的线程处于blocked状态  
**WAITING**: 线程等待状态，等待被其他线程唤醒，如调用Object.wait()时则会进入waiting状态，需要另外的线程调用Object.notify/notifyAll()唤醒  
**TIMED_WAITING**: 具有超时时间的等待状态 （如Thread#sleep，Object#wait(long time)  
**TERMINATED**: 线程终止，线程执行完毕

### Thread#join
`join`方法会使当前运行线程进入等待状态，直到调用`join`的线程实例执行完毕，或者超过等待时间，超时时间不指定默认为0表示永不超时。  

比如现在有线程实例A1、A2和B，A1和A2可以任意一个先执行，但要控制B在A2线程执行完之后执行，则可以通过join控制：   
`A2.start();`  
`A1.start();`  
`// 进入等待状态，直到A2执行完毕`  
`A2.join();`  
`B.start();`

### Object#wait/notify  
用于多线程间的通信，比如

**`wait`**: 释放锁并使当前线程进入等待状态  
**`notify`**: 通知一个处于等待状态的线程竞争该对象的锁  
**`notifyAll`**: 通知全部处于等待状态的线程竞争该对象的锁  

使用前提：当前线程必须是调用Object对象的锁持有者，也就是说**必须在被synchronize修饰的方法或代码块中使用**，否则会抛出`IllegalMonitorStateException`异常。
    

### 生产者与消费者模型
* 使用 wait/notify
* 使用阻塞队列 BlockingQueue
### 背景
最近在做服务架构调整，要将原来跑在was上的应用迁移到tomcat，服务器环境都是新的，问题的出现是在测试环境的某台机器，一共四台测试机，通过SLB做负载均衡。

### 现象
远程上服务器，看日志最新的报错是redis客户端无法建立redis服务器连接， ping了下redis服务是通的。 再往上有一堆数据库连接池的超时报错，ping数据库服务也是通的。
然后试着访问应用服务，发现非常慢，半天打不开一个页面。输入`top`命令一看，好家伙~ tomcat进程cpu占用100%。

### 排查思路
首先分析cpu资源消耗在哪，利用分析工具可以具体到java类的哪个方法  

1. 先用`top`命令找到占用cpu的java进程pid

2. 再输入`top -Hp [pid]`，可以看到进程下所有的线程和它的cpu占用率，找到cpu占用最高的线程pid

3. 输入`jstack [pid] |grep [线程pid] -A 20`, 找到线程的堆栈信息，线程pid需要转16进制，-A 20 意思是显示匹配结果后20行
  
根据线程cpu占用率，大量占用cpu的是VM Thread，这个是虚拟机的运行线程，通过`jstat -gc [pid]`命令，发现MU（metaspace used)空间几乎满了，FGC（full gc)发生了数十万次...  
  
通过gc日志确定了是元数据区内存溢出，一直触发full gc拖慢响应时间，引发各种IO连接超时，最终等待处理的请求积累的越来越多耗尽cpu。元数据区(metaspace)于jdk1.8版本出现，取代了jdk1.7的方法区(永久代), 用于存放类加载器加载的类信息、常量、静态方法等数据。 
    
后续分析原因可能是开启了tomcat热部署，往webapp目录下更新war包时加载类信息过多导致元数据区内存溢出，将这两个参数更新`-XX:MetaspaceSize=768m` `-XX:MaxMetaspaceSize=768m`，分别是元数据区内存和最大元数据区内存，原来为512m，改完重启，后续还有待观察。
